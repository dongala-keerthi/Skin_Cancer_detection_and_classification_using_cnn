# -*- coding: utf-8 -*-
"""mini_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wuO-yMfV7EOgoIVrZyuwNx5ZAwFrliej
"""

#importing the required libraries
import pandas as pd
import numpy as np
import torch
import seaborn as sns
import matplotlib as plt
import warnings
warnings.filterwarnings('ignore')

#unzip and load dataset
!unzip hmnist_28_28_RGB.csv.zip

data_path='hmnist_28_28_RGB.csv'
data_frame=pd.read_csv(data_path)
data_frame.head(20)

data_frame.shape

data_frame.info()

data_frame.describe()

#load the dataset
df = pd.read_csv('HAM10000_metadata.csv')

df.head()

df.info()

df.describe()

df.shape

# train test split
data_frac=np.array([0.8,0.2])
data_frame=data_frame.sample(frac=1)

train_set, test_set = np.array_split(data_frame,(data_frac[:-1].cumsum() * len(data_frame)).astype(int))

#values of test and train sets
print(len(train_set))
print(len(test_set))

#the data labels and division of classes
print(data_frame.label.unique())

classes={
    0:('akc', 'actinic keratoses'),
    1:('bscc' , 'basal cell carcinoma'),
    2:('bkll', 'benign keratosis-like lesions'),
    3:('dtf', 'dermatofibroma'),
    4:('mnv', ' melanocytic nevi'),
    5:('vasc', 'angiomas, angiokeratomas'),
    6:('ml', 'melanoma'),}

y_train=train_set['label']
print(y_train)

x_train=train_set.drop(columns=['label'])

y_test=test_set['label']
print(y_test)

x_test=test_set.drop(columns=['label'])

columns=list(x_train)
print(columns)

#device details
system = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

print(system)

#males effected the most
df['sex'].value_counts()

sns.set_style('whitegrid')
ax = sns.countplot(x='dx', hue='sex', data = df)

#localization plot analysis
sns.set_style('whitegrid')

ax = sns.countplot(x='localization', data=df, order=df['localization'].value_counts().index, palette='crest')

#age based analysis
sns.set_style('whitegrid')
ax = sns.countplot(x = 'age', data = df)

#cancer type affect on patients
sns.set_style('whitegrid')
ax = sns.countplot(x='dx',data=df)

#balancing the data and preprocessing
from imblearn.over_sampling import RandomOverSampler

oversample = RandomOverSampler()

x_train,y_train  = oversample.fit_resample(x_train,y_train)

x_train.shape

sns.countplot(x=y_train)

import matplotlib.pyplot as plt
import random

num=random.randint(0,8000)
x_train=np.array(x_train, dtype=np.uint8).reshape(-1,28,28,3)

plt.imshow(x_train[num].reshape(28,28,3))
plt.title("Random image from the training data")
plt.show()
num=random.randint(0,8000)
plt.imshow(x_train[num].reshape(28,28,3))
plt.title("Random image from the training data")
plt.show()

num=random.randint(0,8000)
plt.imshow(x_train[num].reshape(28,28,3))
plt.title("Random image from the training data")
plt.show()

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x_train,y_train, test_size=0.2)

# creating CNN model
from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D
from keras.layers import Activation, Dropout, Flatten, Dense
import tensorflow as tf

model = Sequential()
model.add(Conv2D(32, (2, 2), input_shape=(28,28,3)))
model.add(Activation('swish'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(32, (2, 2)))
model.add(Activation('swish'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(64, (2, 2)))
model.add(Activation('swish'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Flatten())
model.add(Dense(64))
model.add(Activation('swish'))
model.add(Dropout(0.5))
model.add(Dense(7))
model.add(Activation('softmax'))
model.summary()

model.compile(loss='sparse_categorical_crossentropy',
optimizer='nadam',
metrics=['accuracy'])

callback = tsf.keras.callbacks.ModelCheckpoint(filepath='skin_cancer.h5',
                                              monitor='val_acc',
                                              mode='max',
                                              verbose=1,
                                              save_best_only=True)

early_stopping = tsf.keras.callbacks.EarlyStopping(patience=10, restore_best_weights=True)

#fit the model
from datetime import datetime

start_time = datetime.now()

history = model.fit(x_train,
                    y_train,
                    epochs = 100,
                    validation_split =0.2,
                    callbacks=[callback, early_stopping])

end_time = datetime.now()

print('Duration: {}'.format(end_time - start_time))

#Evaluating the model
plt.plot(history.history['accuracy'])

plt.plot(history.history['val_accuracy'])

plt.title('model accuracy')

plt.ylabel('accuracy')

plt.xlabel('epoch')

plt.legend(['train', 'val'], loc='upper left')

plt.show()

plt.plot(history.history['loss'])

plt.plot(history.history['val_loss'])

plt.title('model loss')

plt.ylabel('loss')

plt.xlabel('epoch')

plt.legend(['train', 'val'], loc='upper left')

plt.show()

# saving the model
model.save('skin_cancer.h5')
print('Model Saved!')

#load the model
model.load_weights('skin_cancer.h5')

x_test=np.array(x_test).reshape(-1,28,28,3)

loss, acc = model.evaluate(x_test, y_test, verbose=2)

model.evaluate(x_train,y_train)

from sklearn.metrics import confusion_matrix

y_pred = model.predict(x_test)
y_pred = np.argmax(y_pred, axis=1)

confusion_mat = confusion_matrix(y_test, y_pred)

#the confusion matrix analysis
import seaborn as sns
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(10,10))


ax = sns.heatmap(confusion_mat, annot=True, cmap='Blues', linewidths=.9, ax=ax)

ax.set_title('Confusion Matrix with labels\n\n');

ax.set_xlabel('\nPredicted Values')

ax.set_ylabel('Actual Values ');

ax.xaxis.set_ticklabels(['0','1','2','3','4','5','6'])

ax.yaxis.set_ticklabels(['0','1','2','3','4','5','6'])

plt.show()

import seaborn as sns
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(10,10))


ax = sns.heatmap(confusion_mat/np.sum(confusion_mat), annot=True, fmt='.2%', cmap='Blues', linewidths=.9, ax=ax)

ax.set_title('Confusion Matrix with labels\n\n');

ax.set_xlabel('\nPredicted Values')

ax.set_ylabel('Actual Values ');

ax.xaxis.set_ticklabels(['0','1','2','3','4','5','6'])

ax.yaxis.set_ticklabels(['0','1','2','3','4','5','6'])

plt.show()

#test a sample image to evaluate
import PIL

image=PIL.Image.open('skin.jpg')

image=image.resize((28,28))

img=x_test[1]

img=np.array(image).reshape(-1,28,28,3)

result=model.predict(img)

print(result[0])

result=result.tolist()

max_prob=max(result[0])

class_ind=result[0].index(max_prob)

print(classes[class_ind])
image.show()